#!/home/akamath/sparky-ai/.venv/bin/python3
"""Sparky AI operator CLI.

Usage:
    sparky status    — Dashboard: step, budget, wandb, GPU, alerts
    sparky logs      — Tail latest session log
    sparky watch     — Auto-refresh status every 30s
    sparky pause     — Pause workflow (graceful, after current session)
    sparky resume    — Resume workflow + start systemd service
    sparky stop      — Stop systemd service immediately
    sparky start     — Start systemd service
    sparky skip <step>  — Skip a step
    sparky retry <step> — Reset a step for retry
    sparky inject "msg" — Inject guidance into next session
    sparky budget    — Detailed budget/cost breakdown
    sparky history   — Step completion timeline
"""

import argparse
import json
import os
import subprocess
import sys
import time
from datetime import datetime, timezone
from pathlib import Path

PROJECT_ROOT = Path("/home/akamath/sparky-ai")
STATE_DIR = PROJECT_ROOT / "workflows" / "state"
LOG_DIR = PROJECT_ROOT / "logs" / "ceo_sessions"
TELEMETRY_DIR = PROJECT_ROOT / "logs" / "telemetry"
ALERTS_LOG = PROJECT_ROOT / "logs" / "alerts.log"
SERVICE_NAME = "sparky-ceo"


def _load_state() -> dict | None:
    """Load the most recent workflow state file."""
    if not STATE_DIR.exists():
        return None
    state_files = sorted(STATE_DIR.glob("*.json"), key=lambda p: p.stat().st_mtime, reverse=True)
    for sf in state_files:
        try:
            with open(sf) as f:
                return json.load(f)
        except (json.JSONDecodeError, OSError):
            continue
    return None


def _save_state(state: dict) -> None:
    """Save workflow state back to disk."""
    name = state.get("workflow_name", "unknown")
    filepath = STATE_DIR / f"{name}.json"
    state["updated_at"] = datetime.now(timezone.utc).isoformat()
    with open(filepath, "w") as f:
        json.dump(state, f, indent=2)


def _get_systemd_status() -> str:
    """Get systemd service status."""
    try:
        result = subprocess.run(
            ["systemctl", "--user", "is-active", SERVICE_NAME],
            capture_output=True, text=True, timeout=5,
        )
        return result.stdout.strip()
    except Exception:
        return "unknown"


def _get_gpu_stats() -> str:
    """Get GPU utilization and memory."""
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=utilization.gpu,memory.used,memory.total",
             "--format=csv,noheader,nounits"],
            capture_output=True, text=True, timeout=5,
        )
        parts = result.stdout.strip().split(", ")
        if len(parts) == 3:
            util, mem_used, mem_total = parts
            return f"{util}% util, {float(mem_used)/1024:.1f}GB/{float(mem_total)/1024:.0f}GB"
    except Exception:
        pass
    return "unavailable"


def _get_wandb_counts(state: dict) -> str:
    """Get wandb run counts by tag."""
    try:
        sys.path.insert(0, str(PROJECT_ROOT / "src"))
        from sparky.tracking.experiment import ExperimentTracker
        tracker = ExperimentTracker(experiment_name="contract_004")
        wf_name = state.get("workflow_name", "")
        # Count by common tags
        tags_to_check = ["sweep", "regime", "ensemble", "feature_analysis"]
        counts = {}
        total = 0
        for tag in tags_to_check:
            c = tracker.count_runs(tags=[wf_name.replace("-", "_"), tag])
            if c > 0:
                counts[tag] = c
                total += c
        if not counts:
            total = tracker.count_runs()
        parts = ", ".join(f"{k}: {v}" for k, v in counts.items())
        return f"{total} runs ({parts})" if parts else f"{total} runs"
    except Exception as e:
        return f"unavailable ({e})"


def _get_best_sharpe(state: dict) -> str:
    """Get best Sharpe from wandb."""
    try:
        sys.path.insert(0, str(PROJECT_ROOT / "src"))
        from sparky.tracking.experiment import ExperimentTracker
        tracker = ExperimentTracker(experiment_name="contract_004")
        best = tracker.best_metric("sharpe")
        if best is not None:
            return f"Sharpe {best:.3f}"
        return "N/A"
    except Exception:
        return "N/A"


def _get_latest_log_line() -> str:
    """Get the last meaningful line from latest.log."""
    latest = LOG_DIR / "latest.log"
    if not latest.exists():
        return "(no log)"
    try:
        # Read last few lines and find last non-empty one
        result = subprocess.run(
            ["tail", "-5", str(latest)],
            capture_output=True, text=True, timeout=5,
        )
        lines = [l.strip() for l in result.stdout.strip().split("\n") if l.strip()]
        if lines:
            line = lines[-1]
            return line[:80] + "..." if len(line) > 80 else line
    except Exception:
        pass
    return "(no log)"


def _get_recent_alerts() -> str:
    """Get recent alerts."""
    if not ALERTS_LOG.exists():
        return "none"
    try:
        result = subprocess.run(
            ["tail", "-3", str(ALERTS_LOG)],
            capture_output=True, text=True, timeout=5,
        )
        lines = [l.strip() for l in result.stdout.strip().split("\n") if l.strip()]
        if lines:
            return "; ".join(lines[-2:])
    except Exception:
        pass
    return "none"


def cmd_status(_args):
    """Print workflow status dashboard."""
    state = _load_state()
    if not state:
        print("No workflow state found.")
        return

    svc_status = _get_systemd_status()
    wf_name = state.get("workflow_name", "unknown")
    steps = state.get("steps", {})
    budget = state.get("budget", {})
    current_idx = state.get("current_step_index", 0)
    total_steps = len(steps)

    # Find current step info
    step_names = list(steps.keys())
    if current_idx < total_steps:
        current_step = step_names[current_idx]
        step_info = steps[current_step]
        attempts = step_info.get("attempts", 0)
        max_retries = 3  # default
        step_status = step_info.get("status", "pending")

        # Estimate elapsed time for current step
        last_attempt = step_info.get("last_attempt_at", "")
        elapsed_str = ""
        if last_attempt and step_status == "running":
            try:
                start = datetime.fromisoformat(last_attempt)
                elapsed = (datetime.now(timezone.utc) - start).total_seconds() / 60
                elapsed_str = f", {elapsed:.0f} min elapsed"
            except Exception:
                pass

        step_line = f"Step {current_idx + 1}/{total_steps}: {current_step} (attempt {attempts}/{max_retries}{elapsed_str})"
    else:
        step_line = f"All {total_steps} steps completed"

    hours_used = budget.get("hours_used", 0)
    max_hours = budget.get("max_hours", 24)
    pct = (hours_used / max_hours * 100) if max_hours > 0 else 0

    gpu_stats = _get_gpu_stats()
    wandb_counts = _get_wandb_counts(state)
    best = _get_best_sharpe(state)
    last_log = _get_latest_log_line()
    alerts = _get_recent_alerts()

    print(f"Sparky AI \u2014 {wf_name} ({svc_status})")
    print(f"{step_line}")
    print(f"Budget: {hours_used:.1f} / {max_hours:.1f} hours ({pct:.0f}%)")
    print(f"Wandb: {wandb_counts}")
    print(f"Best: {best}")
    print(f"GPU: {gpu_stats}")
    print(f"Last log: \"{last_log}\"")
    print(f"Alerts: {alerts}")


def cmd_logs(_args):
    """Tail latest session log."""
    latest = LOG_DIR / "latest.log"
    if not latest.exists():
        print("No log file found.")
        return
    os.execvp("tail", ["tail", "-f", str(latest)])


def cmd_watch(_args):
    """Auto-refresh status every 30s."""
    try:
        while True:
            os.system("clear")
            print(f"[{datetime.now(timezone.utc).strftime('%H:%M:%S UTC')}] sparky watch (Ctrl+C to stop)\n")
            cmd_status(_args)
            print()
            # Show last 10 lines of log
            latest = LOG_DIR / "latest.log"
            if latest.exists():
                result = subprocess.run(
                    ["tail", "-10", str(latest)],
                    capture_output=True, text=True, timeout=5,
                )
                print("--- Latest log ---")
                print(result.stdout.strip())
            time.sleep(30)
    except KeyboardInterrupt:
        print("\nStopped.")


def cmd_pause(_args):
    """Pause workflow."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    (STATE_DIR / "PAUSE").touch()
    print("Workflow paused. Current session will finish, then workflow stops.")
    print("Resume with: sparky resume")


def cmd_resume(_args):
    """Resume workflow."""
    pause_file = STATE_DIR / "PAUSE"
    if pause_file.exists():
        pause_file.unlink()
        print("PAUSE file removed.")
    subprocess.run(["systemctl", "--user", "start", SERVICE_NAME])
    print(f"Started {SERVICE_NAME}.")


def cmd_stop(_args):
    """Stop systemd service."""
    subprocess.run(["systemctl", "--user", "stop", SERVICE_NAME])
    print(f"Stopped {SERVICE_NAME}.")


def cmd_start(_args):
    """Start systemd service."""
    subprocess.run(["systemctl", "--user", "start", SERVICE_NAME])
    print(f"Started {SERVICE_NAME}.")


def cmd_skip(args):
    """Skip a workflow step."""
    state = _load_state()
    if not state:
        print("No workflow state found.")
        return
    step_name = args.step
    steps = state.get("steps", {})
    if step_name not in steps:
        print(f"Step '{step_name}' not found. Available: {', '.join(steps.keys())}")
        return
    steps[step_name]["status"] = "skipped"
    # Advance current_step_index if needed
    step_names = list(steps.keys())
    current_idx = state.get("current_step_index", 0)
    if current_idx < len(step_names) and step_names[current_idx] == step_name:
        state["current_step_index"] = current_idx + 1
    _save_state(state)
    print(f"Step '{step_name}' marked as skipped.")


def cmd_retry(args):
    """Reset a step for retry."""
    state = _load_state()
    if not state:
        print("No workflow state found.")
        return
    step_name = args.step
    steps = state.get("steps", {})
    if step_name not in steps:
        print(f"Step '{step_name}' not found. Available: {', '.join(steps.keys())}")
        return
    steps[step_name]["attempts"] = 0
    steps[step_name]["status"] = "pending"
    _save_state(state)
    print(f"Step '{step_name}' reset for retry (attempts=0, status=pending).")


def cmd_inject(args):
    """Inject guidance into next session."""
    STATE_DIR.mkdir(parents=True, exist_ok=True)
    inject_file = STATE_DIR / "inject.md"
    inject_file.write_text(args.message)
    print(f"Guidance written to {inject_file}")
    print(f"Will be injected into the next Claude session prompt, then deleted.")


def cmd_budget(_args):
    """Show detailed budget and cost breakdown."""
    state = _load_state()
    budget = state.get("budget", {}) if state else {}
    hours_used = budget.get("hours_used", 0)
    max_hours = budget.get("max_hours", 24)
    cost = budget.get("estimated_cost_usd", 0)
    runs = budget.get("runs_completed", 0)

    print(f"Budget: {hours_used:.2f} / {max_hours:.1f} hours ({hours_used/max_hours*100:.1f}%)")
    print(f"Estimated cost: ${cost:.2f}")
    print(f"Total runs: {runs}")

    # Load telemetry files for per-step breakdown
    if TELEMETRY_DIR.exists():
        by_step: dict[str, dict] = {}
        for tf in sorted(TELEMETRY_DIR.glob("*.json")):
            try:
                with open(tf) as f:
                    t = json.load(f)
                step = t.get("step", "unknown")
                if step not in by_step:
                    by_step[step] = {"runs": 0, "hours": 0.0, "cost": 0.0}
                by_step[step]["runs"] += 1
                by_step[step]["hours"] += t.get("duration_minutes", 0) / 60.0
                by_step[step]["cost"] += t.get("estimated_cost_usd", 0)
            except (json.JSONDecodeError, OSError):
                continue

        if by_step:
            print("\nPer-step breakdown:")
            print(f"  {'Step':<30} {'Runs':>5} {'Hours':>8} {'Cost':>8}")
            print(f"  {'-'*30} {'-'*5} {'-'*8} {'-'*8}")
            for step, info in by_step.items():
                print(f"  {step:<30} {info['runs']:>5} {info['hours']:>8.2f} ${info['cost']:>7.2f}")


def cmd_history(_args):
    """Show step completion timeline."""
    state = _load_state()
    if not state:
        print("No workflow state found.")
        return

    steps = state.get("steps", {})
    print(f"Workflow: {state.get('workflow_name', 'unknown')}")
    print(f"Created: {state.get('created_at', 'unknown')}")
    print()
    print(f"  {'Step':<30} {'Status':<12} {'Attempts':>8} {'Completed':>24}")
    print(f"  {'-'*30} {'-'*12} {'-'*8} {'-'*24}")
    for name, info in steps.items():
        completed = info.get("completed_at", "") or "-"
        print(f"  {name:<30} {info.get('status', '?'):<12} {info.get('attempts', 0):>8} {completed:>24}")


def main():
    parser = argparse.ArgumentParser(
        prog="sparky",
        description="Sparky AI operator CLI",
    )
    sub = parser.add_subparsers(dest="command")

    sub.add_parser("status", help="Workflow status dashboard")
    sub.add_parser("logs", help="Tail latest session log")
    sub.add_parser("watch", help="Auto-refresh status")
    sub.add_parser("pause", help="Pause workflow")
    sub.add_parser("resume", help="Resume workflow")
    sub.add_parser("stop", help="Stop systemd service")
    sub.add_parser("start", help="Start systemd service")

    p_skip = sub.add_parser("skip", help="Skip a step")
    p_skip.add_argument("step", help="Step name to skip")

    p_retry = sub.add_parser("retry", help="Reset a step for retry")
    p_retry.add_argument("step", help="Step name to retry")

    p_inject = sub.add_parser("inject", help="Inject guidance")
    p_inject.add_argument("message", help="Message to inject")

    sub.add_parser("budget", help="Budget and cost breakdown")
    sub.add_parser("history", help="Step completion timeline")

    args = parser.parse_args()

    commands = {
        "status": cmd_status,
        "logs": cmd_logs,
        "watch": cmd_watch,
        "pause": cmd_pause,
        "resume": cmd_resume,
        "stop": cmd_stop,
        "start": cmd_start,
        "skip": cmd_skip,
        "retry": cmd_retry,
        "inject": cmd_inject,
        "budget": cmd_budget,
        "history": cmd_history,
    }

    if args.command in commands:
        commands[args.command](args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
